Routes.jsx √© o nosso Main (arquivo principal)

TELAS (componentes) DO APP:

* NAVBAR: Missoes; Recompensas; Desafios; 

*BoxPerfil (leva at√© o Perfil); 
  * AutoAvalia√ß√£o (T√©cnico se autoavalia)
  * Configura√ß√µes (√≠cone Config na tela do perfil);
     * Altera√ß√£o de avatar


* Laudos Pendentes (essa tela existe, mas n√£o possui bot√£o dentro do app para acess√°-la, 
pois ainda n√£o possu√≠mos recursos para faz√™-la funcionar)

_______________________________________________________________________________________________________________

Em Pages/pages.css possui a estiliza√ß√£o geral do app ( estrutura do container, body e button)
_______________________________________________________________________________________________________________

Em *Missoes* a pasta *QualityProgresso* possui a barra de progresso j√° estilizada dos dados de Qaulidade
por√©m, os dados, fetch e componente de Qualidade est√° comentado dentro de Missoes, at√© trazermos os dados corretos.
_______________________________________________________________________________________________________________
*AVATAR* 
 ü†ñ 'Avatar.jsx' √© o componente pai (principal), trata-se da tela que visualizamos no front
 ü†ñ 'AvatarSelector.jsx' √© o componente onde importo as fotos dos avatares e crio o style da sele√ß√£o 
 dos avatares.
 ü†ñ Para adicionar mais avatares no front, fa√ßa a importa√ß√£o 'import avatar21 from xxx' no componente AvatarSelector
  e no 'const avatares' adicione mais uma linha com o mesmo nome 'avatar21'/ n√£o esque√ßa de add a foto do avatar
  na pasta 'client/public/avatar'.
 ü†ñ Todos os avatares est√£o em png.

  *COMO FUNCIONA*
  Ao acessar a tela de Avatares e selecionar seu avatar o controlador (back) analisa pelo userId se o usu√°rio
  j√° possui algum ID_Avatar cadastrado;
  Se sim - ele chama o MODEL setAvatar que faz o UPDATE do atual e altera na tabela SQL o ID_Avatar para o atual
  Se n√£o possui - ele chama o model createAvatar que cria um ID_Avatar para o ID_COLABORADOR na tabela.

  Ou seja, no avatarController as fun√ß√µes que est√£o funcional s√£o: saveAvatar, fetchAvatar.
  Sendo saveAvatar para atualizar ou criar um avatar para o usu√°rio.
  E fetchAvatar para buscar qual ID_Avatar est√° associado ao usu√°rio pelo ID_COLABORADOR. Essa busca (GET) 
  √© feita assim que o usu√°rio faz login no app para que caso a busca encontre um avatar vinculado a ele, sempre
  seja mostrado o avatar que ele cadastrou. 

  *AS TABELAS SQL funcionam da seguinte forma: 
  A tabela UserAvatars possui os dados de todos os avatares (name, id, path)

  A tabela AVATAR_do_COLABORADOR o nome √© sugestivo, √© onde o avatar vincula ao usu√°rio, sendo: 
  ID_Avatar e ID_COLABORADOR


  *EXPLICANDO MODEL DO AVATAR*
  No model foi criado a fun√ß√£o findIdAvatarbyPath para que ao salvar o novo avatar do usu√°rio, ele encontre 
 a foto correta pelo caminho, e armazene seu ID_Avatar. [No controller vc ir√° encontrar:
 await avatarModel.findIdAvatarbyPath(avatarPath)] Em outras palavras ele busca o ID pelo caminho da foto.

  No model foi criado a fun√ß√£o getAvatarDetails que √© semelhante a findIdAvatarbyPath, por√©m ele √© usado no 
  controlador na fun√ß√£o fetchAvatar, pois trata-se da busca da foto do usu√°rio logado. Ent√£o diferente do findIdAvatarbyPath
  Ele busca o caminho da foto pelo ID, para ser mostrada no front. 

 No controller tamb√©m existe a seguinte linha: 
 avatarPath = avatarPath.replace(/\//g, '\\');
Trata-se de uma invers√£o de barras, j√° que na tabela as barras do caminho da foto, ficaram '\' invertidas
Foi necess√°rio essa linha de c√≥digo para converte-la para: /


 ü†ñ O fetch para buscar o Avatar do banco de dados est√° sendo feito no login e na tela de alterar avatar;
 Para navegar at√© outra tela ao clicar em algum bot√£o ou componente, √© ideal usar o navigate do React, pois
 outros hocks podem bugar o avatar;

 ü†ñ A fun√ß√£o handleSaveAvatar no componente 'Avatar.jsx' que faz o fetch de POST para alterar o avatar,
 essa fun√ß√£o √© chamada ao clicar no button 'Alterar Avatar'.

 IMPORTANTE: No inicio de cada componente h√° uma constante para importar a prop do avatar:
 "const { avatar } = useAvatar();"
 e abaixo na fun√ß√£o do componente voc√™ ir√° importar o BoxPerfil com a prop do avatar para que ele funcione em 
 seu novo componente.

<BoxPerfil serverIP={serverIP} avatar={avatar}/>
 _______________________________________________________________________________________________________________

 *NOTIFICA√á√ïES*
 ü†ñ os fetchs de notifica√ß√£o est√£o separados dos componentes, est√£o na pasta 'services'. 
 ü†ñ no BOXPERFIL importamos o:
 'fetchUserNotifications' √© o fetch do usu√°rio, para receber a notifica√ß√£o do user logado e o 
 'Notifications' √© o componente pai.


_______________________________________________________________________________________________________________
*BOXPERFIL*

√â o componente que mostra todas as informa√ß√µes dos usu√°rios (n√≠vel, moedas, progresso em xp, foto e notfica√ß√µes)

Esse componente est√° sendo importado em todas as telas do app.

Ao clicar no BOXPERFIL o usu√°rio √© direcionado para o Meu Perfil, onde ter√° acesso a tabela de habilidades, √≠cone
de Configura√ß√µes, medalhas e auto avalia√ß√£o.

Para importar o componente em uma nova tela abra a tag coloque o nome do componente e feche-a: <BoxPerfil />
√© necess√°rio acrescentar as props de serverIP e avatar dentro dessa importa√ß√£o para funcione os dados trazidos 
do backend: <BoxPerfil serverIP={serverIP} avatar={avatar}/>

Caso o avatar n√£o funcione, esse pode ser o principal motivo.
-------
H√° uma importa√ß√£o de foto chamada 'usuario' que √© usada como foto base, padr√£o, caso o usuario seja novo e n√£o
possua um avatar cadastrado.
-------
Ao iniciar a fun√ß√£o do componente obrigat√≥riamente deve-se usar a prop serverIP com colchetes, exemplo: 
export default function Desafios ({ serverIP }) 
export default function Perfil ({ serverIP }) e apenas no BOXPERFIL √© utilizado a prop avatar, pois √© apenas nele
que mostramos o avatar.
export default function BoxPerfil ({ serverIP, avatar })

_______________________________________________________________________________________________________________
*SERVERIP*

No arquivo routes, onde tem todas as rotas do app, eu criei o serverIP, ele √© uma prop nos outros componentes, que
foi definido dentro de routes.
    const port = '3000'
    const ipAddress = 'localhost';
    const serverIP = `http://${ipAddress}:${port}`;

esse serverIP funciona para que n√£o seja necessario adicionar o localhost:3000 (porta do back end) em todos os outros
componentes, pois todas as telas usam dados do back.
Dessa maneira, caso a porta do back end mude, eu altero o 'port' apenas no routes, e todos os outros componentes
v√£o receber essa altera√ß√£o, sem precisar mexer em todos eles. 

Isso ocorre porqu√™ nos componentes assim que iniciamos a fun√ß√£o adicionamos o serverIP como prop entre colchetes:
Exemplo:
export default function Desafios ({ serverIP }) 
export default function Perfil ({ serverIP })

_______________________________________________________________________________________________________________
*LAUDOS PENDENTES*

O bot√£o no front para acessar essa tela foi removido, pois n√£o ser√° adicionado na primeira vers√£o do app.
_______________________________________________________________________________________________________________